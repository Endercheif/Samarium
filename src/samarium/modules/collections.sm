<=operator;


@ Stack {
    => size? * {
        size <> -/;
        'stack: [];
        'size: size;
    }

    push item * {
        ? 'is_full() {
            "stack is full (size " + ""?!('size) + ")"!!!;
        }
        'stack+: [item];
    }

    push_all items * {
        ... element ->? items {
            'push(element);
        }
    }

    $ * {
        * 'stack$;
    }

    pop * {
        ? 'is_empty() {
            "stack is empty"!!!;
        }
        out: 'stack<<-/>>;
        'stack-: 'stack$ - /;
        * out;
    }

    peek * {
        ? 'is_empty() {
            "stack is empty"!!!;
        }
        * 'stack<<-/>>;
    }

    ? * {
        * 'stack$ > \;
    }

    is_full * {
        * 'size :: 'stack$;
    }

    is_empty * {
        * 'stack$ :: \;
    }

    ! * {
        ?? {
            top: 'peek();
        } !! {
            top:;
        }
        ? top?! :: <-types.String {
            top: <-string.wrap(""?!(top), "\"");
        }
        * "Stack(capacity:" + ""?!('size)
        + ", size:" + ""?!('stack$)
        + ", top:" + ""?!(top)
        + ")";
    }
}

@ Queue {
    => size? * {
        size <> -/;
        'queue: [];
        'size: size;
    }

    $ * {
        * 'queue$;
    }

    is_empty * {
        * ~~ '$;
    }

    is_full * {
        * '$ :: 'size;
    }

    throw_empty * {
        ? 'is_empty() {
            "queue is empty"!!!;
        }
    }

    put item * {
        ? 'is_full() {
            "queue is full (size " + ""?!('size) + ")"!!!;
        }
        'queue+: [item];
    }

    put_all items * {
        ... item ->? items {
            'put(item);
        }
    }

    get * {
        'throw_empty();
        out: 'queue<<\>>;
        'queue-: \;
        * out;
    }

    first * {
        'throw_empty(); * 'queue<<\>>;
    }

    last * {
        'throw_empty(); * 'queue<<-/>>;
    }

    ? * {
        * '$ > \;
    }

    ! * {
        <=string.wrap;
        <=types.String;
        ? '$ <: /\/ {
            items: ""?!('queue);
        } ,, ? '$ > /\/ {
            first: ""?!('first());
            last: ""?!('last());
            ? 'first()?! :: String {
                first: wrap(first, "\"");
            }
            ? 'last()?! :: String {
                last: wrap(last, "\"");
            }
            items: "[" + ""?!(first) + ", ..., " + ""?!(last) + "]";
        } ,, {
            items: "[]";
        }
        * "Queue(capacity:" + ""?!('size)
        + ", size:" + ""?!('queue$)
        + ", items:" + items + ")";
    }
}

@ Set {
    => items? capacity? * {
        items <> [];
        capacity <> -/;
        'find: <-iter.find;
        'items: [i ... i ->? items] ? items ,, [];
        'capacity: capacity;
    }

    $ * {
        * 'items$;
    }

    + value * {
        ? value ~~ ->? ' {
            ? 'is_full() {
                "set is full (capacity " + ""?!('capacity) + ")"!!!;
            }
            'items+: [value];
            * /;
        }
        * \;
    }

    ? * {
        * ~~ 'is_empty();
    }

    ! * {
        * "Set(capacity:" + ""?!('capacity)
        + ", size:" + ""?!('$)
        + ", items:" + ""?!('items)
        + ")";
    }

    remove value * {
        'items-: [value];
    }

    ->? value * {
        * 'find('items, value) >: \;
    }

    values * {
        * 'items;
    }

    clear * {
        'items: [];
    }

    is_empty * {
        * '$ :: \;
    }

    is_full * {
        * '$ :: 'capacity;
    }

    new_set_size a b * {
        * a$ ? a$ > b$ ,, b$;
    }

    union other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + ""?!(other?!)!!!;
        }

        union_set: Set('values(), 'new_set_size(', other) ++ /\);

        ... value ->? other.values() {
            union_set+: value;
        }

        * union_set;
    }

    intersection other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + ""?!(other?!)!!!;
        }

        intersection_set: Set([], 'new_set_size(', other));

        ... value ->? 'values() {
            ? value ->? other {
                intersection_set+: value;
            }
        }

        * intersection_set;
    }

    difference other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + ""?!(other?!)!!!;
        }

        difference_set: Set([], 'new_set_size(', other));

        ... value ->? 'values() {
            ? value ~~ ->? other {
                difference_set+: value;
            }
        }

        * difference_set;
    }

    is_subset other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + ""?!(other?!)!!!;
        }

        ? '$ > other$ { * \; }

        ... value ->? 'values() {
            ? ~~ other.has(value) { * \; }
        }
        * /;
    }
}

@ Deque {

    => size? * {
        size <> -/;
        'deque: [];
        'size: size;
    }

    $ * {
        * 'deque$;
    }

    is_empty * {
        * ~~ '$;
    }

    is_full * {
        * '$ :: 'size;
    }

    throw_empty * {
        ? 'is_empty() {
            "deque is empty"!!!;
        }
    }

    throw_full * {
        ? 'is_full() {
            "deque is full (size " + ""?!('size) + ")"!!!;
        }
    }

    put_front item * {
        'throw_full(); 'deque: [item] + 'deque;
    }

    put item * {
        'throw_full(); 'deque+: [item];
    }

    put_front_all items * {
        ... item ->? items {
            'put_front(item);
        }
    }

    put_all items * {
        ... item ->? items {
            'put(item);
        }
    }

    front * {
        * 'deque<<\>>;
    }

    back * {
        * 'deque<<-/>>;
    }

    ? * {
        * '$ > \;
    }

    get_front * {
        'throw_empty();
        out: 'deque<<\>>;
        'deque-: \;
        * out;
    }

    get * {
        'throw_empty();
        out: 'deque<<-/>>;
        'deque-: 'deque$ - /;
        * out;
    }

    ! * {
        <=string.wrap;
        <=types.String;
        ? '$ <: /\/ {
            items: ""?!('deque);
        } ,, ? '$ > /\/ {
            front: ""?!('front());
            back: ""?!('back());
            ? 'front()?! :: String {
                front: wrap(front, "\"");
            }
            ? 'back()?! :: String {
                back: wrap(back, "\"");
            }
            items: "[" + ""?!(front) + ", ..., " + ""?!(back) + "]";
        } ,, {
            items: "[]";
        }
        * "Deque(capacity:" + ""?!('size)
        + ", size:" + ""?!('deque$)
        + ", items:" + items + ")";
    }
}

@ StaticArray {
    => value type? * {
        type <>;
        ? value?! :: <-types.Integer {
            'value: {{}};
            'size: value;
            'type: type;
        } ,, ? value?! :: <-types.Array {
            'value: {{}};
            'size: value$;
            'type: type;
            i: \;
            ... e ->? value {
                ? e?! ::: type ::: {
                    "expected " + ""?!(type) + ", found " + ""?!(e?!)!!!;
                }
                'value<<i>>: e;
                i+: /;
            }
        } ,, {
            "expected Integer or Array, found " + ""?!(value?!)!!!;
        }
    }

    $ * {
        * 'value$;
    }

    ! * {
        * "StaticArray(size:" + ""?!('size)
        + ", type:" + ""?!('type)
        + ", items:" + ""?!('value)
        + ")";
    }

    ? * {
        * / ? 'value ,, \;
    }

    throw_invalid_index arg * {
        ? arg?! ::: <-types.Integer {
            "expected Integer, received " + ""?!(arg?!)!!!;
        }
        ? ~~ (\ <: arg < 'size) {
            "index " + ""?!(arg) + " is out of bounds (size " + ""?!('size) + ")"!!!;
        }
    }

    throw_invalid_type type * {
        ? type ::: 'type ::: {
            "expected " + ""?!('type) + ", received " + ""?!(type)!!!;
        }
    }

    <<>> index * {
        'throw_invalid_index(index);
        * 'value<<index>>;
    }

    <<>>: index value * {
        'throw_invalid_index(index);
        'throw_invalid_type(value?!);
        'value<<index>>: value;
    }

}

@ ArithmeticArray {
    => array * {
        'array: array;
    }

    apply op other * {
        * ArithmeticArray([op(i, other) ... i ->? 'array]);
    }

    & other * {
        * 'apply(operator.and, other);
    }

    + other * {
        * 'apply(operator.add, other);
    }

    -- other * {
        * 'apply(operator.div, other);
    }

    :: other * {
        * 'apply(operator.eq, other);
    }

    >: other * {
        * 'apply(operator.ge, other);
    }

    > other * {
        * 'apply(operator.gt, other);
    }

    <: other * {
        * 'apply(operator.le, other);
    }

    < other * {
        * 'apply(operator.lt, other);
    }

    --- other * {
        * 'apply(operator.mod, other);
    }

    ++ other * {
        * 'apply(operator.mul, other);
    }

    ::: other * {
        * 'apply(operator.ne, other);
    }

    | other * {
        * 'apply(operator.or, other);
    }

    +++ other * {
        * 'apply(operator.pow, other);
    }

    - other * {
        * 'apply(operator.sub, other);
    }

    ^ other * {
        * 'apply(operator.xor, other);
    }

    <<>> item * {
        out: 'array<<item>>;
        ? out?! :: <-types.Array {
            * ArithmeticArray(out);
        }
        * out;
    }

    <<>>: item value * {
        'array<<item>>: value;
    }

    $ * {
        * 'array$;
    }

    ? * {
        * / ? 'array ,, \;
    }

    ! * {
        * ""?!('array);
    }
}